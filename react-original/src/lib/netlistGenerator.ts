import { PFCInputs, PFCResults } from './calculations';

export interface NetlistComponents {
  mosfet: any;
  capacitor: any;
  inductor: any;
}

export function generatePFCNetlist(
  inputs: PFCInputs,
  results: PFCResults,
  components: NetlistComponents
): string {
  const { v_in_min, v_in_max, v_out_min, switching_freq, line_freq_min } = inputs;
  const { inductance, capacitance } = results;
  const { mosfet, capacitor, inductor } = components;

  // Convert to LTSpice units
  const L_value = `${(inductance * 1e6).toFixed(2)}u`; // Convert to ÂµH
  const C_value = `${(capacitance * 1e6).toFixed(2)}u`; // Convert to ÂµF
  const freq = switching_freq / 1000; // Convert to kHz
  const line_freq = line_freq_min;

  const netlist = `* PFC Boost Converter - Auto-generated by CircuitAI
* Design Specifications:
* Input Voltage: ${v_in_min}V - ${v_in_max}V AC
* Output Voltage: ${v_out_min}V DC
* Switching Frequency: ${freq}kHz
* Line Frequency: ${line_freq}Hz

* Input AC Source
V1 N001 0 SINE(0 ${v_in_max * 1.414} ${line_freq})

* Bridge Rectifier
D1 N001 N002 D1N4148
D2 0 N002 D1N4148
D3 N001 0 D1N4148
D4 N003 N002 D1N4148

* PFC Inductor
L1 N002 N003 ${L_value}
.ic I(L1)=0

* MOSFET Switch
M1 N003 N004 0 0 ${mosfet?.part_number || 'IRF640'}
.model ${mosfet?.part_number || 'IRF640'} NMOS(Rds=${mosfet?.rds_on || 0.18} Vt=3 Cgs=${mosfet?.qg || 50}n)

* Gate Drive Signal
V2 N004 0 PULSE(0 12 0 50n 50n ${1/(2*switching_freq*1000)} ${1/(switching_freq*1000)})

* Output Diode
D5 N003 N005 MUR460
.model MUR460 D(Is=1e-12 Rs=0.05)

* Output Capacitor
C1 N005 0 ${C_value} Rser=${capacitor?.esr || 0.05}
.ic V(N005)=${v_out_min}

* Load Resistor
R1 N005 0 ${(v_out_min * v_out_min) / (inputs.p_out_max)}

* Simulation Commands
.tran 0 ${10/line_freq} ${5/line_freq} ${1/(switching_freq*1000*100)}
.meas TRAN Vout_avg AVG V(N005)
.meas TRAN Vout_ripple PP V(N005)
.meas TRAN IL_peak MAX I(L1)
.meas TRAN efficiency PARAM (V(N005)*I(R1))/(V1*I(V1))

.backanno
.end
`;

  return netlist;
}

export function parseLTSpiceOutput(output: string) {
  // Parse LTSpice output and extract key metrics
  const measurements: any = {};
  
  const lines = output.split('\n');
  lines.forEach(line => {
    if (line.includes('vout_avg')) {
      measurements.vout_avg = parseFloat(line.split('=')[1]);
    }
    if (line.includes('vout_ripple')) {
      measurements.vout_ripple = parseFloat(line.split('=')[1]);
    }
    if (line.includes('il_peak')) {
      measurements.il_peak = parseFloat(line.split('=')[1]);
    }
    if (line.includes('efficiency')) {
      measurements.efficiency = parseFloat(line.split('=')[1]);
    }
  });
  
  return measurements;
}
